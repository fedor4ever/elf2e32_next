// Copyright (c) 2020 Strizhniou Fiodar
// All rights reserved.
// This component and the accompanying materials are made available
// under the terms of "Eclipse Public License v1.0"
// which accompanies this distribution, and is available
// at the URL "http://www.eclipse.org/legal/epl-v10.html".
//
// Initial Contributors:
// Strizhniou Fiodar - initial contribution.
//
// Contributors:
//
// Description:
// Build E32Image and other companions
//
//

#include <vector>
#include <cstdint>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <iostream>
#include <algorithm>

#include "task.hpp"
#include "symbol.h"
#include "deffile.h"
#include "dsofile.h"
#include "common.hpp"
#include "e32common.h"
#include "elfparser.h"
#include "elf2e32_opt.hpp"
#include "artifactbuilder.h"
#include "symbolprocessor.h"
#include "elf2e32_version.hpp"

void FixHeaderName(Args* fix);
void MakeImportHeader(Symbols symbols, std::string dllName);
void ValidateOptions(Args* arg);
void ValidateCaps(Args* arg);
std::string ResolveLinkAsUID(const Args* arg);
std::string VersionAsStr(uint32_t version);

ArtifactBuilder::ArtifactBuilder(Args* param): iOpts(param)
{
    //ctor
}

ArtifactBuilder::~ArtifactBuilder()
{
    //dtor
}

void ArtifactBuilder::Run()
{
    PrepareBuild();
    MakeDSO();
    MakeDef();
    MakeE32();
    MakeImportHeader(iSymbols, iOpts->iHeader);
}

void ArtifactBuilder::PrepareBuild()
{
    ValidateOptions(iOpts);
    if(!iOpts->iElfinput.empty())
    {
        iElfParser = new ElfParser(iOpts->iElfinput);
        iElfParser->GetElfFileLayout();
    }
    SymbolProcessor processor(iOpts, iElfParser);
    iSymbols = processor.GetExports();
    DsoImpLibName();
}

void ArtifactBuilder::DsoImpLibName()
{
    if(iOpts->iDefinput.empty())
        return;
    DefFile d;
    d.GetSymbols(iOpts->iDefinput.c_str());
    iDsoImpLibName = d.GetDsoImpLibName();
    if(iOpts->iDSODump)
        iDsoImpLibName = iElfParser->DsoImpLibName();
}

void ArtifactBuilder::MakeDSO()
{
    if(iOpts->iDso.empty())
        return;
    DSOFile* dso = new DSOFile();
    dso->WriteDSOFile(iOpts, iSymbols, iDsoImpLibName);
    delete dso;
}

void ArtifactBuilder::MakeDef()
{
    if(iOpts->iDefoutput.empty())
        return;
    DefFile deffile;

    std::vector<std::string> tmp;
    if(iOpts->iDSODump)
        deffile.SetDsoImpLibName(iDsoImpLibName);
    deffile.WriteDefFile(iOpts->iDefoutput.c_str(), iSymbols);
}

void ArtifactBuilder::MakeE32()
{
    if(iOpts->iOutput.empty())
        return;
    BuildE32Image(iOpts, iElfParser, iSymbols);
}

void FixHeaderName(Args* fix)
{
    if(fix->iHeader.empty())
        return;

    std::string headerName;
    if(!fix->iElfinput.empty())
        headerName = fix->iElfinput;
    else if(!fix->iOutput.empty())
        headerName = fix->iOutput;
    else if(!fix->iDso.empty())
        headerName = fix->iDso;
    else if(!fix->iDefinput.empty())
        headerName = fix->iDefinput;
    else if(!fix->iDefoutput.empty())
        headerName = fix->iDefoutput;
    else
        ReportError(ErrorCodes::UNKNOWNHEADERNAME);
    fix->iHeader = headerName;
    fix->iHeader += ".h";
}

void MakeImportHeader(Symbols symbols, std::string dllName)
{
    if(dllName.empty())
        return;

    std::fstream fstr(dllName, std::fstream::out | std::fstream::trunc);
    ToolVersion ver;
    auto it = symbols.begin();

    fstr << "//This file generated by elf2e32 ";
    fstr << (uint32_t)ver.iMajor << "." << (uint32_t)ver.iMinor << "." << ver.iBuild;
    fstr << " to easy dynamic linking.\n";
    fstr << "//Usage example:\n// #include <e32std.h>\n// RLibrary library;\n";
    fstr << "// User::LeaveIfError(library.Load(" << dllName << "));\n";
    fstr << "// TLibraryFunction entry=library.Lookup(" << (*it)->AliasName() << ");\n";
    fstr << "// Call the function to create new CMessenger\n"
        "// CMessenger* messenger=(CMessenger*) entry();\n";
    fstr << "// library.Close();\n";

    fstr << "#ifndef ELF2E32_" << dllName << "\n";
    fstr << "#define ELF2E32_" << dllName << "\n";
    for(auto x: symbols)
    {
        fstr << "#define " << x->AliasName() << "\t" << x->Ordinal() << "\n";
    }

    fstr << "#endif // ELF2E32_" << dllName << "\n";
    fstr.close();
}

bool IsRunnable(TargetType type)
{
    if((type == TargetType::EExe) || (type == TargetType::EExexp)
       || (type == TargetType::EStdExe))
       return true;
    return false;
}

//* Return entrypoint symbol for various plugins
std::string GetEcomExportName(TargetType type)
{
    switch(type)
    {
    case TargetType::EAni:
        return "_Z15CreateCAnimDllLv,1;";
    case TargetType::EFsy:
        return "CreateFileSystem,1;";
    case TargetType::ELdd:
        return "_Z19CreateLogicalDevicev,1;";
    case TargetType::EPdd:
        return "_Z20CreatePhysicalDevicev,1;";
    case TargetType::EPdl:
        return "_Z17NewPrinterDeviceLv,1;";
    case TargetType::EPlugin:
    case TargetType::EPlugin3: //fallthru
        return "_Z24ImplementationGroupProxyRi,1;";
    case TargetType::ETextNotifier2:
        return "_Z13NotifierArrayv,1;";
    case TargetType::EVar:
        return "_Z17VariantInitialisev,1;";
    case TargetType::EVar2:
        return "VariantInitialise,1;";
    default:
        ReportError(ErrorCodes::INVALIDARGUMENT, "--targettype", std::to_string(type));
    }
    ReportError(ErrorCodes::INVALIDARGUMENT, "--targettype", std::to_string(type));
    return "";
}

void WarnForNonDllUID()
{
    ReportLog("********************\n");
    ReportLog("Wrong UID1\n");
    ReportLog("Set uid1 to KDynamicLibraryUidValue\n");
    ReportLog("********************\n");
}

void WarnForNonExeUID()
{
    ReportLog("********************\n");
    ReportLog("Wrong UID1\n");
    ReportLog("Set uid1 to KExecutableImageUidValue\n");
    ReportLog("********************\n");
}

std::string VersionAsStr(uint32_t version)
{
    if((version == 0x000a0000u) || (version == 0))
        return "{000a0000}";
    std::stringstream buf;
    buf << "{" << std::setw(8) << std::hex << std::setfill('0') << version << "}";
    return buf.str();
}

/** \brief Reset invalid option --linkas
 *
 * Valid option looks like: --linkas=foo{000a0000}[10011237].dll
 * It contain 4 parts:
 * 1) target name: "foo"
 * 2) target version(hex form): "{000a0000}"
 * 3) target UID3(hex form): "[10011237]"
 * 4) file extension
 *
 * If UID3 == 0 part 3 not present in builds in SDK
 * S60_5th_Edition_SDK_v1.0 for exe and dll, stdexe and stddll
 */
void ResetInvalidLINKAS(Args* arg)
{
    if(arg->iLinkas.empty())
        return;

    size_t first = arg->iLinkas.find_first_of("{");
    size_t last = arg->iLinkas.find_first_of("}");
    size_t fst = arg->iLinkas.find_first_of("[");
    size_t lst = arg->iLinkas.find_first_of("]");

    auto pos = std::string::npos;

    bool head = (first == pos) || (last == pos) || (last < first);
    bool zeroUID3 = ((last - first) != 9);
    bool nonzeroUID3 = ( ((last - first) != 9) && ((lst - fst) != 9)) ||
                (fst == pos) || (lst == pos) || (lst < fst);
    bool tail = (arg->iUid3 > 0) ? nonzeroUID3: zeroUID3;

    if(head || tail)
    {
        ReportWarning(ErrorCodes::ZEROBUFFER, "Illformed option: " + arg->iLinkas + "\n");
        ReportWarning(ErrorCodes::ZEROBUFFER, "Example: --linkas=foo{000a0000}[10011237].dll\n");
        ReportWarning(ErrorCodes::ZEROBUFFER, "Ignoring --linkas option\n\n");
        arg->iLinkas.clear();
    }
}

void DeduceLINKAS(Args* arg)
{
    if(arg->iLinkas.empty() && (arg->iTargettype != TargetType::EInvalidTargetType))
    {
        std::string linkas, version;
        version = VersionAsStr(arg->iVersion);
        if(!arg->iOutput.empty())
        {
            linkas = arg->iOutput;
            linkas.insert(linkas.find_last_of("."), version);
            linkas.insert(linkas.find_last_of("."), arg->iLinkasUid);
        }
        else if(!arg->iDefoutput.empty())
        {
            linkas = arg->iDefoutput;
            linkas.erase(linkas.find_last_of("."));
            linkas += version;
            linkas += arg->iLinkasUid;
            linkas += ".dll";
        }
        else if(!arg->iDso.empty())
        {
            linkas = arg->iDso;
            linkas.erase(linkas.find_last_of("."));
            linkas += version;
            linkas += arg->iLinkasUid;
            linkas += ".dll";
        }
        arg->iLinkas = FileNameFromPath(linkas);
    }

    if(VerboseOut())
        ReportLog("Linkas option: " + arg->iLinkas + "\n");
}

const std::string linkAsError = "Failure while reconstructing linkas option from UID3";
void ResolveLinkAsUID(Args* arg)
{
    if(arg->iUid3 == 0)
    {
        arg->iLinkasUid.erase();
        return;
    }

    if( !arg->iLinkasUid.empty() && (arg->iLinkasUid[0] == '0') &&
       ((arg->iLinkasUid[1] == 'x') || (arg->iLinkasUid[1] == 'X')) )
    {
        ReportLog("LinkasUid: " + arg->iLinkasUid + '\n');
        arg->iLinkasUid.erase(0, 2);
        ReportLog("LinkasUid: " + arg->iLinkasUid + '\n');
            ReportLog("arg->iLinkasUid.size(): %d\n", arg->iLinkasUid.size());
        arg->iLinkasUid.insert(0, 8 - arg->iLinkasUid.size(), '0');
        ReportLog("LinkasUid: " + arg->iLinkasUid + '\n');
        arg->iLinkasUid = '[' + arg->iLinkasUid + ']';
        ReportLog("LinkasUid: " + arg->iLinkasUid + '\n');
        ReportLog("\n");
        return;
    }

    std::stringstream buf;
    buf << "[" << std::setw(8) << std::hex << std::setfill('0') << arg->iUid3 << "]";
    if(buf.bad())
        ReportError(ErrorCodes::ZEROBUFFER, linkAsError);

    arg->iLinkasUid = buf.str();
}

/** \brief Verifies and correct wrong input options
 * This function correct multiple conflict opions
 * like --datapaging with different params,
 * also fix wrong uid1 for exe and dll
 */
void ValidateOptions(Args* arg)
{
    FixHeaderName(arg);

    ValidateCaps(arg);

    if((arg->iDebuggable) && !IsRunnable(arg->iTargettype))
    {
        arg->iDebuggable = false;
        ReportLog("--debuggable option allowed for EXE's only!\n");
    }

    bool hasDefinput = !arg->iDefinput.empty();
    bool noDefOut = arg->iDefoutput.empty();
    bool noElfinput = arg->iElfinput.empty();
    bool noE32Image = arg->iOutput.empty();
    TargetType targetType = arg->iTargettype;

    if(!arg->iHeader.empty() && !noElfinput)
        return;

// convert .dso to .def
    if(!noElfinput && !noDefOut && noE32Image)
    {
        arg->iDSODump = true;
        return;
    }

    if(!hasDefinput && arg->iNamedlookup)
        ReportLog("Note: if option \"--namedlookup\" supplied and \"--definput\" omitted E32"
                "image generated that tool differs from SDK tool output for code relocs"
                "section. Correctness unknown.\n");

    if(targetType == TargetType::EInvalidTargetType || targetType == TargetType::ETargetTypeNotSet)
    {
        ReportWarning(ErrorCodes::NOREQUIREDOPTION, "--targettype");
        if(hasDefinput)
            arg->iTargettype = TargetType::EImportLib;
// handle special Custom target
        else if(!noDefOut || !arg->iDso.empty())
            arg->iTargettype = TargetType::EDll;
        else
            arg->iTargettype = TargetType::EExe;
        targetType = arg->iTargettype;
    }

    ResolveLinkAsUID(arg);
    ResetInvalidLINKAS(arg);
    DeduceLINKAS(arg);

    if((targetType == TargetType::EPlugin) && arg->iSysdef.empty())
        arg->iSysdef = GetEcomExportName(targetType);

    if(hasDefinput && noElfinput)
        arg->iTargettype = TargetType::EImportLib;

    uint32_t UID1 = arg->iUid1, UID2 = arg->iUid2, UID3 = arg->iUid3;
    if(!arg->iSid)
        arg->iSid = UID3;

    switch(arg->iTargettype)
    {
    case TargetType::ETargetTypeNotSet:
        break;
    case TargetType::EInvalidTargetType:
        break;
    case TargetType::EImportLib:
        if(!hasDefinput)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--definput");
        if(arg->iDso.empty())
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--dso");
        break;
    case TargetType::EStdDll:
        if(noElfinput)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--elfinput");
        if(noE32Image)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--output");

        if(UID1 != KDynamicLibraryUidValue) //< guard against wrong uids
            WarnForNonDllUID();
        arg->iUid1 = KDynamicLibraryUidValue;
        arg->iUid2 = KSTDTargetUid2Value;

        if(!UID3) ReportLog("Missed --uid3 option!\n");
        break;
    case TargetType::EDll:
        if(noElfinput)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--elfinput");
        if(noE32Image)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--output");

        if(UID1 != KDynamicLibraryUidValue) //< guard against wrong uids
            WarnForNonDllUID();
        arg->iUid1 = KDynamicLibraryUidValue;
        if(!UID2)
        {
            ReportLog("********************\n");
            ReportLog("missed value for UID2\n");
            ReportLog("********************\n");
        }
        if(arg->iTargettype == TargetType::EStdDll) arg->iUid2 = KSTDTargetUid2Value; // only that uid2 accepted for STDDLL & STDEXE
        if(!UID3) ReportLog("Missed --uid3 option!\n");
        break;
    case TargetType::EExe:
        if(noElfinput)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--elfinput");
        if(noE32Image)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--output");
        if(UID1 != KExecutableImageUidValue)
            WarnForNonExeUID();
        arg->iUid1 = KExecutableImageUidValue;
        if(!UID3) ReportLog("Missed --uid3 option!\n");
        break;
    case TargetType::EAni:
    case TargetType::EFep: //fallthru
    case TargetType::EFsy: //fallthru
    case TargetType::ELdd: //fallthru
    case TargetType::EPlugin: //fallthru
    case TargetType::EPlugin3: //fallthru
    case TargetType::EPdd: //fallthru
    case TargetType::EPdl: //fallthru
    case TargetType::ETextNotifier2: //fallthru
        if(noE32Image && noElfinput)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--elfinput ""--output");
        if(noElfinput)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--elfinput");
        if(noE32Image)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--output");
        if(UID1 != KDynamicLibraryUidValue)
            WarnForNonDllUID();
        arg->iUid1 = KDynamicLibraryUidValue;
        if(!UID2)
        {
            ReportLog("********************\n");
            ReportLog("Wrong UID2\n");
            ReportLog("Set UID2 to %u\n", arg->iTargettype);
            ReportLog("********************\n");
        }
        arg->iUid2 = arg->iTargettype;
        if(!UID3) ReportLog("Missed --uid3 option!\n");
        break;
    case EExexp:
        if(noElfinput)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--elfinput");
        if(noDefOut)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--defoutput");
        if(noE32Image)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--output");

        if(UID1 != KExecutableImageUidValue)
            WarnForNonExeUID();
        arg->iUid1 = KExecutableImageUidValue;
        if(!UID2) ReportLog("Missed --uid2 option!\n");
        if(!UID3) ReportLog("Missed --uid3 option!\n");
        break;
    case EStdExe:
        if(noElfinput)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--elfinput");
        if (noE32Image)
            ReportError(ErrorCodes::NOREQUIREDOPTION, "--output");
        if(UID1 != KExecutableImageUidValue)
            WarnForNonExeUID();
        arg->iUid1 = KExecutableImageUidValue;
        arg->iUid2 = KSTDTargetUid2Value;

        if(!UID3) ReportLog("Missed --uid3 option!\n");
        break;
    default:
        break;
    }
}

void ValidateCaps(Args* arg)
{
    auto pos = std::string::npos;
    std::string caps = ToLower(arg->iCapability);

    if(caps.empty())
        ReportError(ErrorCodes::ZEROBUFFER, "Internal error! Default capabilities value lost!");
    if((caps[0] == '-') || (caps[0] == '+'))
        ReportError(ErrorCodes::INVALIDARGUMENT, "capability", caps);
//  If we have nonsence like All+AllFiles
    if( (caps.find("all") != caps.find("allfiles")) && (caps.find('+') < pos) && (caps.find("allfiles") == pos) )
        ReportError(ErrorCodes::INVALIDARGUMENT, "capability", caps);
}
